[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R para Ciência de Dados (2ª edição)",
    "section": "",
    "text": "Boas-vindas\nEste é o website para a tradução em Português da 2ª edição do livro “R for Data Science”. Este livro vai te ensinar como fazer ciência de dados com R: você irá aprender como importar os seus dados para o R, arrumá-los em uma estrutura mais útil, transformá-los e visualizá-los.\nNeste livro, você vai encontrar um conjunto de habilidades para a ciência de dados. Assim como estudantes de química aprendem a limpar tubos de ensaio e montar um laboratório, você vai aprender a limpar dados e fazer gráficos – além de muitas outras coisas. Essas são as habilidades que fazem a ciência de dados acontecer, e aqui você vai encontrar as melhores práticas para fazer cada uma dessas coisas com o R. Você vai aprender a usar a gramática dos gráficos, programação letrada (literate programming) e pesquisa reprodutível para economizar tempo. Você também vai aprender a gerenciar recursos cognitivos para facilitar descobertas ao lidar com, visualizar e explorar dados.\nEste site é e sempre será gratuito, licenciado sob a Licença CC BY-NC-ND 3.0. Se você gostaria de ter uma cópia física do livro, você pode comprar a versão em Inglês na Amazon. Se você aprecia ler o livro gratuitamente e gostaria de retribuir, por favor faça uma doação para a Kākāpō Recovery: o kākāpō (que aparece na capa do livro) é uma espécie de papagaio nativa da Nova Zelândia que está criticamente ameaçada de extinção; restam apenas 248 espécimes.\nVocê pode encontrar respostas sugeridas para exercícios no livro em https://mine-cetinkaya-rundel.github.io/r4ds-solutions.\nPor favor, note que o R4DS utiliza um Código de Conduta de Contribuidores. Ao contribuir para este livro, você concorda em seguir seus termos.\nSe você fala outra língua, pode se interessar pelas traduções gratuitas da primeira edição do livro:\nPor favor, note que o R4DS usa um Código de Conduta para Contribuidores. Ao contribuir para este livro, você concorda em seguir estes termos."
  },
  {
    "objectID": "index.html#agradecimentos",
    "href": "index.html#agradecimentos",
    "title": "R para Ciência de Dados (2ª edição)",
    "section": "Agradecimentos",
    "text": "Agradecimentos\nA versão original do livro (em Inglês) é hospedada pela https://www.netlify.com como parte de seu apoio ao software e às comunidades open source."
  },
  {
    "objectID": "preface-2e.html",
    "href": "preface-2e.html",
    "title": "Prefácio da segunda edição",
    "section": "",
    "text": "Boas vindas à segunda edição do livro “R para Ciência de Dados”! Esta é uma revisão importante da primeira edição, removendo material que não consideramos mais útil, adicionando material que gostaríamos de ter incluído na primeira edição e atualizando o texto e o código de acordo com as melhores práticas. Também estamos muito animados em dar as boas-vindas a uma nova co-autora: Mine Çetinkaya-Rundel, uma renomada educadora em ciência de dados e uma de nossas colegas na Posit (conhecida anteriormente como RStudio).\nSegue abaixo um breve resumo das maiores mudanças nesta edição:\n\nA primeira parte do livro foi renomeada para “Visão geral”. O objetivo desta seção é fornecer a você os detalhes aproximados da “visão geral” da ciência de dados antes de nos aprofundarmos nos detalhes.\nA segunda parte do livro é chamada “Visualizar”. Esta parte oferece uma cobertura mais abrangente das ferramentas e práticas recomendadas de visualização de dados em comparação à primeira edição. O melhor lugar para obter todos os detalhes ainda é o livro do ggplot2, mas agora o R4DS aborda de forma mais abrangente as técnicas importantes.\nA terceira parte do livro agora é chamada de “Transformar” e inclui novos capítulos sobre números, vetores lógicos e valores faltantes (missing values - NA). Esses tópicos eram anteriormente parte do capítulo de transformação de dados, mas precisavam de mais espaço para cobrir todos os detalhes.\nA quarta parte do livro é chamada de “Importar”. São novos capítulos que vão além da leitura de arquivos de texto simples para trabalhar com planilhas, importar dados de bancos de dados (databases), trabalhar com grandes conjuntos de dados (big data), converter dados hierárquicos em dados tabulares e extrair dados de sites da web (web scraping).\nA parte “Programar” permanece, mas foi reescrita do zero para se concentrar nas partes mais importantes da escrita de funções e iteração. Agora, a escrita de funções inclui detalhes sobre como criar funções no estilo tidy (lidando com os desafios de avaliação tidy (tidy evaluation)), uma vez que isso se tornou muito mais fácil e importante nos últimos anos. Adicionamos um novo capítulo sobre funções importantes do R base que você provavelmente encontrará em códigos em R por aí.\nA parte de modelagem foi removida. Nunca tivemos espaço suficiente para fazer justiça à modelagem e agora existem recursos muito melhores disponíveis. Geralmente, recomendamos o uso do pacote tidymodels e a leitura do livro Tidy Modeling with R escrito por Max Kuhn e Julia Silge.\nA parte de “Comunicar” permanece, mas foi atualizada em detalhes para apresentar o Quarto em vez do R Markdown. Esta edição do livro foi escrita no Quarto e ele claramente é a ferramenta do futuro."
  },
  {
    "objectID": "intro.html#o-que-você-aprenderá",
    "href": "intro.html#o-que-você-aprenderá",
    "title": "Introdução",
    "section": "O que você aprenderá",
    "text": "O que você aprenderá\nA ciência de dados é um campo vasto, e não é possível dominá-la lendo apenas um único livro. Este livro tem como objetivo fornecer a você uma base sólida nas ferramentas mais importantes e conhecimento suficiente para encontrar os recursos necessários para aprender mais quando for preciso. Nosso modelo das etapas de um projeto típico de ciência de dados se parece com Figura 1.\n\n\n\n\nFigura 1: Em nosso modelo do processo de ciência de dados, você começa com a importação e organização dos dados. Em seguida, você entende seus dados por meio de um ciclo iterativo de transformação, visualização e modelagem. Você finaliza o ciclo comunicando seus resultados para outras pessoas.\n\n\n\nPrimeiro, você deve importar seus dados para o R. Isso geralmente significa que você pega dados armazenados em um arquivo, um banco de dados ou uma API (interface de programação de aplicação, ou Application Programming Interface em inglês) da web e importa em uma tabela (data frame) no R. Se você não conseguir importar seus dados para o R, não poderá fazer ciência de dados com eles!\nDepois de importar seus dados, é uma boa ideia organizá-los .\nOrganizar seus dados significa armazená-los em uma forma consistente que corresponda à semântica do conjunto de dados com a forma como ele é armazenado. Em resumo, quando seus dados estão organizados de forma tidy1, cada coluna é uma variável e cada linha é uma observação.\nDados organizados (tidy data) são importantes porque a estrutura consistente permite que você concentre seus esforços em responder perguntas sobre os dados, em vez de lutar para colocar os dados na forma correta para usar diferentes funções.\nDepois de ter dados organizados, normalmente o próximo passo é transformá-los. A transformação inclui focar em observações de interesse (como todas as pessoas em uma cidade ou todos os dados do último ano), criar novas variáveis que são funções de variáveis existentes (como calcular a velocidade a partir da distância e do tempo) e calcular um conjunto de estatísticas resumidas (como contagens ou médias). Juntos, organizar e transformar são chamados de manipulação de dados2.\nUma vez que você tenha dados organizados e com as variáveis de que precisa, existem duas principais fontes de geração de conhecimento: visualização e modelagem. Essas têm pontos fortes e fracos complementares, portanto, qualquer análise de dados real irá iterar entre elas muitas vezes.\nVisualização é uma atividade fundamentalmente humana. Uma boa visualização mostrará coisas que você não esperava ou levantará novas questões sobre os dados. Uma boa visualização também pode sugerir que você está fazendo a pergunta errada ou que precisa coletar dados diferentes. As visualizações podem surpreender você, mas não escalam particularmente bem porque exigem que um ser humano as interprete.\nModelos são ferramentas complementares à visualização. Depois de tornar suas perguntas suficientemente precisas, você pode usar um modelo para respondê-las. Os modelos são fundamentalmente ferramentas matemáticas ou computacionais, então geralmente escalam bem. Mesmo quando não o fazem, geralmente é mais barato comprar mais computadores do que comprar mais cérebros! No entanto, cada modelo faz suposições, e, por sua própria natureza, um modelo não pode questionar suas próprias suposições. Isso significa que um modelo não pode, fundamentalmente, surpreendê-lo.\nA última etapa da ciência de dados é a comunicação, uma parte absolutamente crítica de qualquer projeto de análise de dados. Não importa o quão bem seus modelos e visualizações tenham ajudado você a entender os dados, a menos que você também possa comunicar seus resultados para outras pessoas.\nEm torno de todas essas ferramentas está a programação. A programação é uma ferramenta abrangente que é usada em quase todas as partes de um projeto de ciência de dados. Não é necessário ser uma pessoa especialista em programação para ter sucesso na ciência de dados, mas aprender mais sobre programação compensa, pois se tornar melhor em programação permite automatizar tarefas comuns e resolver novos problemas com maior facilidade.\nVocê usará essas ferramentas em todos os projetos de ciência de dados, mas para a maioria deles, elas não são suficientes. Há uma regra aproximada de 80/20 em jogo: você pode abordar cerca de 80% de cada projeto usando as ferramentas que aprenderá neste livro, mas precisará de outras ferramentas para lidar com os 20% restantes. Ao longo deste livro, indicaremos recursos onde você pode aprender mais."
  },
  {
    "objectID": "intro.html#como-este-livro-está-organizado",
    "href": "intro.html#como-este-livro-está-organizado",
    "title": "Introdução",
    "section": "Como este livro está organizado",
    "text": "Como este livro está organizado\nA descrição anterior das ferramentas da ciência de dados está organizada aproximadamente de acordo com a ordem em que você as utiliza em uma análise (embora, é claro, você vá iterar por elas várias vezes). Em nossa experiência, no entanto, aprender primeiro a importação e organização de dados não é a melhor escolha, porque essas tarefas são, 80% do tempo, rotineiras e entediantes, e nos outros 20% do tempo, são estranhas e frustrantes. Esse não é um bom ponto de partida para aprender um novo assunto! Em vez disso, começaremos com a visualização e transformação de dados que já foram importados e organizados. Dessa forma, quando você importar e organizar seus próprios dados, sua motivação permanecerá alta, porque você sabe que o esforço vale a pena.\nDentro de cada capítulo, procuramos seguir um padrão consistente: começar com alguns exemplos motivadores para que você possa entender o panorama geral e, em seguida, aprofundar nos detalhes. Cada seção do livro é acompanhada de exercícios para ajudar você a praticar o que aprendeu. Embora possa ser tentador pular os exercícios, a melhor maneira de aprender é praticando com problemas reais."
  },
  {
    "objectID": "intro.html#o-que-você-não-aprenderá",
    "href": "intro.html#o-que-você-não-aprenderá",
    "title": "Introdução",
    "section": "O que você não aprenderá",
    "text": "O que você não aprenderá\nExistem vários tópicos importantes que este livro não aborda. Acreditamos que é importante manter um foco rigoroso no essencial para que você possa começar o mais rápido possível. Isso significa que não é possível, neste livro, abordar todos os tópicos importantes.\nModelagem\nA modelagem é extremamente importante para a ciência de dados, mas é um tópico amplo e, infelizmente, não temos espaço suficiente para abordá-lo adequadamente aqui. Para aprender mais sobre modelagem, recomendamos fortemente o livro Tidy Modeling with R, escrito por nossos colegas Max Kuhn e Julia Silge. O livro Tidy Modeling with R ensinará a você a família de pacotes tidymodels, que, como você pode imaginar pelo nome, compartilha muitas convenções com os pacotes do tidyverse que usamos neste livro.\nBig data\nEste livro orgulhosamente e principalmente foca em conjuntos de dados pequenos e que cabem na memória3 (in-memory).\nEste é o lugar certo para começar, porque você não poderá lidar com big data a menos que já tenha experiência com bases de dados pequenas. As ferramentas que você aprenderá ao longo da maior parte deste livro lidarão facilmente com centenas de megabytes de dados e, com um pouco de cuidado, você geralmente poderá usá-las para trabalhar com alguns gigabytes de dados. Também mostraremos como obter dados de bancos de dados e arquivos parquet, ambos frequentemente usados para armazenar big data. Você não necessariamente conseguirá trabalhar com o conjunto de dados inteiro, mas isso nem sempre é um problema, pois, em muitos casos, você só precisa de um subconjunto ou uma amostra para responder à pergunta que te interessa.\nSe você está rotineiramente lidando com dados maiores (digamos, de 10 a 100 GB), recomendamos aprender mais sobre o pacote data.table. Não o ensinamos aqui porque ele usa uma interface diferente do tidyverse e requer que você aprenda algumas convenções diferentes. No entanto, ele é incrivelmente mais rápido, e o retorno no desempenho compensa o tempo investido para aprender a usá-lo, se você estiver trabalhando com big data.\nPython, Julia e outros\nNeste livro, você não aprenderá nada sobre Python, Julia ou qualquer outra linguagem de programação útil para a ciência de dados. Isso não é porque achamos que essas ferramentas são ruins. Elas não são! E, na prática, a maioria das equipes de ciência de dados usa uma combinação de linguagens, muitas vezes pelo menos R e Python. Mas acreditamos firmemente que é melhor dominar uma ferramenta de cada vez, e R é um ótimo ponto de partida."
  },
  {
    "objectID": "intro.html#pré-requisitos",
    "href": "intro.html#pré-requisitos",
    "title": "Introdução",
    "section": "Pré-requisitos",
    "text": "Pré-requisitos\nFizemos algumas suposições sobre o que você já deveria saber para aproveitar ao máximo este livro. Você deve ter uma compreensão geral de matemática e é útil se você já tiver alguma experiência básica em programação. Se você nunca programou antes, pode achar o livro Hands on Programming with R, escrito por Garrett, um recurso valioso para complementar este livro.\nVocê precisará de quatro coisas para executar os códigos deste livro: R, RStudio, um conjunto de pacotes R chamado tidyverse e alguns outros pacotes. Pacotes são as unidades fundamentais de código R reprodutível. Eles incluem funções reutilizáveis, documentação que descreve como usá-los e dados de exemplo.\nR\nPara baixar o R, acesse o CRAN, o comprehensive R archive network, em https://cloud.r-project.org. Uma nova versão principal do R é lançada anualmente, e há 2-3 lançamentos menores a cada ano. É uma boa ideia atualizar regularmente. A atualização pode ser um pouco complicada, especialmente para as versões principais que exigem que você reinstale todos os seus pacotes, mas adiá-la só torna as coisas piores. Recomendamos o R 4.2.0 ou posterior para este livro.\nRStudio\nO RStudio é uma IDE (ambiente de desenvolvimento integrado), para programação em R, que você pode baixar em https://posit.co/download/rstudio-desktop/. O RStudio é atualizado algumas vezes por ano e ele o informará automaticamente quando uma nova versão estiver disponível, portanto, não é necessário verificar periodicamente. É uma boa ideia atualizar regularmente para aproveitar os recursos mais recentes e melhorados. Para este livro, certifique-se de ter pelo menos o RStudio 2022.02.0.\nQuando você inicia o RStudio, Figura 2, você verá duas partes principais na interface: o painel de console (Console) e o painel de saída (Output). Por enquanto, tudo o que você precisa saber é que você digita o código R no Console e pressiona Enter para executá-lo. Você aprenderá mais à medida que avançarmos!4\n\n\n\n\nFigura 2: O RStudio possui duas partes principais: digite o código em R no Console à esquerda e procure o painel Plots dentro do painel Output à direita.\n\n\n\nO tidyverse\nVocê também precisará instalar alguns pacotes do R. Um pacote do R é uma coleção de funções, dados e documentação que estende as capacidades do R base. O uso de pacotes é fundamental para o uso bem-sucedido do R. A maioria dos pacotes que você aprenderá neste livro faz parte do chamado tidyverse. Todos os pacotes no tidyverse compartilham uma filosofia comum de dados e programação em R e são projetados para funcionar juntos.\nVocê pode instalar o tidyverse completo com uma única linha de código:\n\ninstall.packages(\"tidyverse\")\n\nEm seu computador, digite essa linha de código no console e pressione Enter para executá-la. O R fará o download dos pacotes do CRAN e os instalará em seu computador.\nVocê não poderá usar as funções, objetos ou arquivos de ajuda de um pacote até carregá-lo com library(). Depois de instalar um pacote, você pode carregá-lo usando a função library():\n\nlibrary(tidyverse)\n#&gt; ── Attaching core tidyverse packages ───────────────────── tidyverse 2.0.0 ──\n#&gt; ✔ dplyr     1.1.3     ✔ readr     2.1.4\n#&gt; ✔ forcats   1.0.0     ✔ stringr   1.5.0\n#&gt; ✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n#&gt; ✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n#&gt; ✔ purrr     1.0.2     \n#&gt; ── Conflicts ─────────────────────────────────────── tidyverse_conflicts() ──\n#&gt; ✖ dplyr::filter() masks stats::filter()\n#&gt; ✖ dplyr::lag()    masks stats::lag()\n#&gt; ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nIsso informa que o tidyverse carrega nove pacotes: dplyr, forcats, ggplot2, lubridate, purrr, readr, stringr, tibble, tidyr. Esses são considerados o núcleo do tidyverse porque você os usará em quase todas as análises.\nOs pacotes do tidyverse mudam com bastante frequência. Você pode verificar se há atualizações disponíveis executando tidyverse_update().\nOutros pacotes\nExistem muitos outros pacotes excelentes que não fazem parte do tidyverse porque resolvem problemas em um domínio diferente ou são projetados com um conjunto diferente de princípios subjacentes. Isso não os torna melhores ou piores; apenas os torna diferentes. Em outras palavras, o complemento ao tidyverse não é o messyverse5, mas muitos outros universos de pacotes inter-relacionados.\nConforme você enfrenta mais projetos de ciência de dados com R, aprenderá novos pacotes e novas formas de pensar sobre dados.\nUsaremos muitos pacotes de fora do tidyverse neste livro. Por exemplo, usaremos os seguintes pacotes porque eles fornecem conjuntos de dados interessantes para trabalharmos no processo de aprendizado do R:\n\ninstall.packages(\n  c(\"arrow\", \"curl\", \"dados\", \"duckdb\",\n    \"ggrepel\", \"ggridges\", \"ggthemes\", \"hexbin\", \"janitor\",  \n    \"leaflet\", \"maps\", \"openxlsx\", \n    \"repurrrsive\", \"tidymodels\", \"writexl\")\n  )\n\nTambém usaremos uma seleção de outros pacotes para exemplos isolados. Você não precisa instalá-los agora, apenas lembre-se de que sempre que vir um erro como este:\n\nlibrary(ggrepel)\n#&gt; Error in library(ggrepel) : there is no package called ‘ggrepel’\n\nVocê precisará executar install.packages(\"ggrepel\") para instalar o pacote."
  },
  {
    "objectID": "intro.html#executando-código-em-r",
    "href": "intro.html#executando-código-em-r",
    "title": "Introdução",
    "section": "Executando código em R",
    "text": "Executando código em R\nA seção anterior mostrou vários exemplos de execução de código em R. O código no livro parece assim:\n\n1 + 2\n#&gt; [1] 3\n\nSe você executar o mesmo código no seu console, ele parecerá assim:\n&gt; 1 + 2\n[1] 3\nExistem duas diferenças principais. No seu console, você digita após o &gt;, chamado de prompt; não mostramos o prompt no livro. No livro, a saída é comentada com #&gt;; no seu console, ela aparece diretamente após o código. Essas duas diferenças significam que se você estiver trabalhando com uma versão online do livro, poderá copiar facilmente o código do livro e colá-lo no console.\nAo longo do livro, usamos um conjunto consistente de convenções para se referir ao código:\n\nFunções são exibidas em uma fonte de código e seguidas por parênteses, como sum() ou mean().\nOutros objetos R (como dados ou argumentos de função) estão em uma fonte de código, sem parênteses, como voos ou x.\nÀs vezes, para deixar claro de qual pacote um objeto vem, usaremos o nome do pacote seguido por quatro-pontos ::, como dplyr::mutate() ou dados::voos. Isso também é código em R válido."
  },
  {
    "objectID": "intro.html#agradecimentos",
    "href": "intro.html#agradecimentos",
    "title": "Introdução",
    "section": "Agradecimentos",
    "text": "Agradecimentos\nEste livro não é apenas o produto de Hadley, Mine e Garrett, mas é o resultado de muitas conversas (pessoalmente e online) que tivemos com muitas pessoas na comunidade R. Estamos incrivelmente gratos por todas as conversas que tivemos com todos vocês; muito obrigado!\nEste livro foi escrito de forma colaborativa e muitas pessoas contribuíram por meio de pull requests. Um agradecimento especial a todas as 259 pessoas que contribuíram com melhorias por meio de pull requests no GitHub (em ordem alfabética pelo nome de usuário): @a-rosenberg, Tim Becker (@a2800276), Abinash Satapathy (@Abinashbunty), Adam Gruer (@adam-gruer), adi pradhan (@adidoit), A. s. (@Adrianzo), Aep Hidyatuloh (@aephidayatuloh), Andrea Gilardi (@agila5), Ajay Deonarine (@ajay-d), @AlanFeder, Daihe Sui (@alansuidaihe), @alberto-agudo, @AlbertRapp, @aleloi, pete (@alonzi), Alex (@ALShum), Andrew M. (@amacfarland), Andrew Landgraf (@andland), @andyhuynh92, Angela Li (@angela-li), Antti Rask (@AnttiRask), LOU Xun (@aquarhead), @ariespirgel, @august-18, Michael Henry (@aviast), Azza Ahmed (@azzaea), Steven Moran (@bambooforest), Brian G. Barkley (@BarkleyBG), Mara Averick (@batpigandme), Oluwafemi OYEDELE (@BB1464), Brent Brewington (@bbrewington), Bill Behrman (@behrman), Ben Herbertson (@benherbertson), Ben Marwick (@benmarwick), Ben Steinberg (@bensteinberg), Benjamin Yeh (@bentyeh), Betul Turkoglu (@betulturkoglu), Brandon Greenwell (@bgreenwell), Bianca Peterson (@BinxiePeterson), Birger Niklas (@BirgerNi), Brett Klamer (@bklamer), @boardtc, Christian (@c-hoh), Caddy (@caddycarine), Camille V Leonard (@camillevleonard), @canovasjm, Cedric Batailler (@cedricbatailler), Christina Wei (@christina-wei), Christian Mongeau (@chrMongeau), Cooper Morris (@coopermor), Colin Gillespie (@csgillespie), Rademeyer Vermaak (@csrvermaak), Chloe Thierstein (@cthierst), Chris Saunders (@ctsa), Abhinav Singh (@curious-abhinav), Curtis Alexander (@curtisalexander), Christian G. Warden (@cwarden), Charlotte Wickham (@cwickham), Kenny Darrell (@darrkj), David Kane (@davidkane9), David (@davidrsch), David Rubinger (@davidrubinger), David Clark (@DDClark), Derwin McGeary (@derwinmcgeary), Daniel Gromer (@dgromer), @Divider85, @djbirke, Danielle Navarro (@djnavarro), Russell Shean (@DOH-RPS1303), Zhuoer Dong (@dongzhuoer), Devin Pastoor (@dpastoor), @DSGeoff, Devarshi Thakkar (@dthakkar09), Julian During (@duju211), Dylan Cashman (@dylancashman), Dirk Eddelbuettel (@eddelbuettel), Edwin Thoen (@EdwinTh), Ahmed El-Gabbas (@elgabbas), Henry Webel (@enryH), Ercan Karadas (@ercan7), Eric Kitaif (@EricKit), Eric Watt (@ericwatt), Erik Erhardt (@erikerhardt), Etienne B. Racine (@etiennebr), Everett Robinson (@evjrob), @fellennert, Flemming Miguel (@flemmingmiguel), Floris Vanderhaeghe (@florisvdh), @funkybluehen, @gabrivera, Garrick Aden-Buie (@gadenbuie), Peter Ganong (@ganong123), Gerome Meyer (@GeroVanMi), Gleb Ebert (@gl-eb), Josh Goldberg (@GoldbergData), bahadir cankardes (@gridgrad), Gustav W Delius (@gustavdelius), Hao Chen (@hao-trivago), Harris McGehee (@harrismcgehee), @hendrikweisser, Hengni Cai (@hengnicai), Iain (@Iain-S), Ian Sealy (@iansealy), Ian Lyttle (@ijlyttle), Ivan Krukov (@ivan-krukov), Jacob Kaplan (@jacobkap), Jazz Weisman (@jazzlw), John Blischak (@jdblischak), John D. Storey (@jdstorey), Gregory Jefferis (@jefferis), Jeffrey Stevens (@JeffreyRStevens), 蒋雨蒙 (@JeldorPKU), Jennifer (Jenny) Bryan (@jennybc), Jen Ren (@jenren), Jeroen Janssens (@jeroenjanssens), @jeromecholewa, Janet Wesner (@jilmun), Jim Hester (@jimhester), JJ Chen (@jjchern), Jacek Kolacz (@jkolacz), Joanne Jang (@joannejang), @johannes4998, John Sears (@johnsears), @jonathanflint, Jon Calder (@jonmcalder), Jonathan Page (@jonpage), Jon Harmon (@jonthegeek), JooYoung Seo (@jooyoungseo), Justinas Petuchovas (@jpetuchovas), Jordan (@jrdnbradford), Jeffrey Arnold (@jrnold), Jose Roberto Ayala Solares (@jroberayalas), Joyce Robbins (@jtr13), @juandering, Julia Stewart Lowndes (@jules32), Sonja (@kaetschap), Kara Woo (@karawoo), Katrin Leinweber (@katrinleinweber), Karandeep Singh (@kdpsingh), Kevin Perese (@kevinxperese), Kevin Ferris (@kferris10), Kirill Sevastyanenko (@kirillseva), Jonathan Kitt (@KittJonathan), @koalabearski, Kirill Müller (@krlmlr), Rafał Kucharski (@kucharsky), Kevin Wright (@kwstat), Noah Landesberg (@landesbergn), Lawrence Wu (@lawwu), @lindbrook, Luke W Johnston (@lwjohnst86), Kara de la Marck (@MarckK), Kunal Marwaha (@marwahaha), Matan Hakim (@matanhakim), Matthias Liew (@MatthiasLiew), Matt Wittbrodt (@MattWittbrodt), Mauro Lepore (@maurolepore), Mark Beveridge (@mbeveridge), @mcewenkhundi, mcsnowface, PhD (@mcsnowface), Matt Herman (@mfherman), Michael Boerman (@michaelboerman), Mitsuo Shiota (@mitsuoxv), Matthew Hendrickson (@mjhendrickson), @MJMarshall, Misty Knight-Finley (@mkfin7), Mohammed Hamdy (@mmhamdy), Maxim Nazarov (@mnazarov), Maria Paula Caldas (@mpaulacaldas), Mustafa Ascha (@mustafaascha), Nelson Areal (@nareal), Nate Olson (@nate-d-olson), Nathanael (@nateaff), @nattalides, Ned Western (@NedJWestern), Nick Clark (@nickclark1000), @nickelas, Nirmal Patel (@nirmalpatel), Nischal Shrestha (@nischalshrestha), Nicholas Tierney (@njtierney), Jakub Nowosad (@Nowosad), Nick Pullen (@nstjhp), @olivier6088, Olivier Cailloux (@oliviercailloux), Robin Penfold (@p0bs), Pablo E. Garcia (@pabloedug), Paul Adamson (@padamson), Penelope Y (@penelopeysm), Peter Hurford (@peterhurford), Peter Baumgartner (@petzi53), Patrick Kennedy (@pkq), Pooya Taherkhani (@pooyataher), Y. Yu (@PursuitOfDataScience), Radu Grosu (@radugrosu), Ranae Dietzel (@Ranae), Ralph Straumann (@rastrau), Rayna M Harris (@raynamharris), @ReeceGoding, Robin Gertenbach (@rgertenbach), Jajo (@RIngyao), Riva Quiroga (@rivaquiroga), Richard Knight (@RJHKnight), Richard Zijdeman (@rlzijdeman), @robertchu03, Robin Kohrs (@RobinKohrs), Robin (@Robinlovelace), Emily Robinson (@robinsones), Rob Tenorio (@robtenorio), Rod Mazloomi (@RodAli), Rohan Alexander (@RohanAlexander), Romero Morais (@RomeroBarata), Albert Y. Kim (@rudeboybert), Saghir (@saghirb), Hojjat Salmasian (@salmasian), Jonas (@sauercrowd), Vebash Naidoo (@sciencificity), Seamus McKinsey (@seamus-mckinsey), @seanpwilliams, Luke Smith (@seasmith), Matthew Sedaghatfar (@sedaghatfar), Sebastian Kraus (@sekR4), Sam Firke (@sfirke), Shannon Ellis (@ShanEllis), @shoili, Christian Heinrich (@Shurakai), S’busiso Mkhondwane (@sibusiso16), SM Raiyyan (@sm-raiyyan), Jakob Krigovsky (@sonicdoe), Stephan Koenig (@stephan-koenig), Stephen Balogun (@stephenbalogun), Steven M. Mortimer (@StevenMMortimer), Stéphane Guillou (@stragu), Sulgi Kim (@sulgik), Sergiusz Bleja (@svenski), Tal Galili (@talgalili), Alec Fisher (@Taurenamo), Todd Gerarden (@tgerarden), Tom Godfrey (@thomasggodfrey), Tim Broderick (@timbroderick), Tim Waterhouse (@timwaterhouse), TJ Mahr (@tjmahr), Thomas Klebel (@tklebel), Tom Prior (@tomjamesprior), Terence Teo (@tteo), @twgardner2, Ulrik Lyngs (@ulyngs), Shinya Uryu (@uribo), Martin Van der Linden (@vanderlindenma), Walter Somerville (@waltersom), @werkstattcodes, Will Beasley (@wibeasley), Yihui Xie (@yihui), Yiming (Paul) Li (@yimingli), @yingxingwu, Hiroaki Yutani (@yutannihilation), Yu Yu Aung (@yuyu-aung), Zach Bogart (@zachbogart), @zeal626, Zeki Akyol (@zekiakyol)."
  },
  {
    "objectID": "intro.html#considerações-finais",
    "href": "intro.html#considerações-finais",
    "title": "Introdução",
    "section": "Considerações Finais",
    "text": "Considerações Finais\nA versão online deste livro está disponível em https://cienciadedatos.github.io/pt-r4ds/. O código fonte do livro está disponível em https://github.com/cienciadedatos/pt-r4ds. O livro é gerado pelo Quarto, que facilita a escrita de livros que combinam texto e código executável."
  },
  {
    "objectID": "intro.html#footnotes",
    "href": "intro.html#footnotes",
    "title": "Introdução",
    "section": "",
    "text": "Nota de tradução: tidy é tanto um verbo em inglês que quer dizer “arrumar/organizar”, quanto um paradigma de estruturação de dados. O capítulo ?sec-data-tidy abordará este conceito.↩︎\nNota de tradução: Manipulação de dados é chamado em inglês de data wrangling, porque colocar seus dados em uma forma natural de trabalhar frequentemente parece uma luta (wrangle)!↩︎\nNota de tradução: “Caber na memória” se refere à memória RAM (random access memory) do computador, cuja função é guardar temporariamente toda a informação que o computador precisa (por exemplo, as bases de dados importadas).↩︎\nSe você deseja uma visão abrangente de todos os recursos do RStudio, consulte o Guia de uso do RStudio em https://docs.posit.co/ide/user.↩︎\nNota de tradução: tidyverse é a união das palavras tidy (arrumado) e universe (universo), sendo então a ideia de um “universo arrumado”. messy quer dizer desarrumado, e messyverse seria a ideia de um universo desarrumado.↩︎"
  },
  {
    "objectID": "whole-game.html",
    "href": "whole-game.html",
    "title": "Whole game",
    "section": "",
    "text": "Our goal in this part of the book is to give you a rapid overview of the main tools of data science: importing, tidying, transforming, and visualizing data, as shown in Figura 1. We want to show you the “whole game” of data science giving you just enough of all the major pieces so that you can tackle real, if simple, datasets. The later parts of the book will hit each of these topics in more depth, increasing the range of data science challenges that you can tackle.\n\n\n\n\nFigura 1: In this section of the book, you’ll learn how to import, tidy, transform, and visualize data.\n\n\n\nFour chapters focus on the tools of data science:\n\nVisualization is a great place to start with R programming, because the payoff is so clear: you get to make elegant and informative plots that help you understand data. In Capítulo 1 you’ll dive into visualization, learning the basic structure of a ggplot2 plot, and powerful techniques for turning data into plots.\nVisualization alone is typically not enough, so in ?sec-data-transform, you’ll learn the key verbs that allow you to select important variables, filter out key observations, create new variables, and compute summaries.\nIn ?sec-data-tidy, you’ll learn about tidy data, a consistent way of storing your data that makes transformation, visualization, and modelling easier. You’ll learn the underlying principles, and how to get your data into a tidy form.\nBefore you can transform and visualize your data, you need to first get your data into R. In ?sec-data-import you’ll learn the basics of getting .csv files into R.\n\nNestled among these chapters are four other chapters that focus on your R workflow. In ?sec-workflow-basics, ?sec-workflow-style, and ?sec-workflow-scripts-projects you’ll learn good workflow practices for writing and organizing your R code. These will set you up for success in the long run, as they’ll give you the tools to stay organized when you tackle real projects. Finally, ?sec-workflow-getting-help will teach you how to get help and keep learning."
  },
  {
    "objectID": "data-visualize.html#introdução",
    "href": "data-visualize.html#introdução",
    "title": "1  Visualização de dados",
    "section": "\n1.1 Introdução",
    "text": "1.1 Introdução\n\n“O gráfico simples trouxe mais informações à mente dos analistas de dados do que qualquer outro dispositivo.” — John Tukey\n\nO R possui diversos sistemas para construir gráficos, mas o ggplot2 é um dos mais elegantes e versáteis. O ggplot2 implementa a gramática dos gráficos, um sistema coerente para descrever e construir gráficos. Com o ggplot2 você pode fazer mais, e mais rápido, ao aprender um sistema e aplicá-lo em muitos lugares.\nEste capítulo irá te ensinar como visualizar seus dados usando o ggplot2. Nós vamos começar criando um gráfico de dispersão simples e usá-lo para introduzir o mapeamento de atributos estéticos (aesthetic) e geometrias – os blocos fundamentais na construção do ggplot2. Nós vamos então te orientar na visualização de distribuições de variáveis individuais, bem como na visualização de relações entre duas ou mais variáveis. Terminaremos salvando seus gráficos e com dicas de resolução de problemas.\n\n1.1.1 Pré-requisitos\nEste capítulo tem foco no ggplot2, um dos principais pacotes do tidyverse. Para acessar os bancos de dados, páginas de ajuda e funções utilizadas neste capítulo, você deve carregar o tidyverse executando o comando:\n\nlibrary(tidyverse)\n#&gt; ── Attaching core tidyverse packages ───────────────────── tidyverse 2.0.0 ──\n#&gt; ✔ dplyr     1.1.3     ✔ readr     2.1.4\n#&gt; ✔ forcats   1.0.0     ✔ stringr   1.5.0\n#&gt; ✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n#&gt; ✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n#&gt; ✔ purrr     1.0.2     \n#&gt; ── Conflicts ─────────────────────────────────────── tidyverse_conflicts() ──\n#&gt; ✖ dplyr::filter() masks stats::filter()\n#&gt; ✖ dplyr::lag()    masks stats::lag()\n#&gt; ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nEssa única linha de código carrega os pacotes essenciais do tidyverse, que você irá utilizar em quase toda análise de dados. Ela também te diz quais funções do tidyverse possuem conflitos com as função do R base (ou de outro pacote que você tenha carregado)1.\nSe você rodar este código e receber a mensagem de erro there is no package called 'tidyverse', você precisará instalar o pacote antes usando a função install.packages() ou a interface de instalação do RStudio, e então rodar library() novamente.\n\ninstall.packages(\"tidyverse\")\nlibrary(tidyverse)\n\nVocê só precisa instalar um pacote uma vez, mas precisa carregá-lo sempre que iniciar uma nova sessão.\nAlém do tidyverse, nós também usaremos o pacote dados, que inclui várias bases de dados, incluindo um com medidas corporais de pinguins de três ilhas do Arquipélago Palmer, junto do pacote ggthemes, que fornece uma paleta de cores segura para pessoas com daltonismo.\n\nlibrary(dados)\nlibrary(ggthemes)"
  },
  {
    "objectID": "data-visualize.html#primeiros-passos",
    "href": "data-visualize.html#primeiros-passos",
    "title": "1  Visualização de dados",
    "section": "\n1.2 Primeiros passos",
    "text": "1.2 Primeiros passos\nOs pinguins com nadadeiras mais compridas pesam mais ou menos que pinguins com nadadeiras curtas? Você provavelmente já tem uma resposta, mas tente torná-la mais precisa. Como é a relação entre o comprimento da nadadeira e massa corporal? Ela é positiva? Negativa? Linear? Não linear? A relação varia com a espécie do pinguim? E quanto à ilha onde o pinguim vive? Vamos criar visualizações que podemos usar para responder essas perguntas.\n\n1.2.1 O data frame pinguins\n\nVocê pode testar suas respostas à essas questões usando o data frame pinguins encontrado no pacote dados (usando dados::pinguins). Um data frame é uma coleção tabular (formato de tabela) de variáveis (nas colunas) e observações (nas linhas). pinguins contém 344 observações coletadas e disponibilizadas pela Dra. Kristen Gorman e pelo PELD Estação Palmer, Antártica2.\nPara facilitar a discussão, vamos definir alguns termos:\n\nUma variável é uma quantidade, qualidade ou propriedade que você pode medir.\nUm valor é o estado de uma variável quando você a mede. O valor de uma variável pode mudar de medição para medição.\nUma observação é um conjunto de medições feitas em condições semelhantes (geralmente todas as medições em uma observação são feitas ao mesmo tempo e no mesmo objeto). Uma observação conterá vários valores, cada um associado a uma variável diferente. Às vezes, vamos nos referir a uma observação como um ponto de dados.\nDados tabulares são um conjunto de valores, cada um associado a uma variável e uma observação. Os dados tabulares estarão no formato tidy (arrumado) se cada valor estiver em sua própria “célula”, cada variável em sua própria coluna e cada observação em sua própria linha.\n\nNeste contexto, uma variável refere-se a um atributo de todos os pinguins, e uma observação refere-se a todos os atributos de um único pinguim.\nDigite o nome do data frame no console e o R mostrará uma visualização de seu conteúdo. Observe que aparece escrito tibble no topo desta visualização. No tidyverse, usamos data frames especiais chamados tibbles, dos quais você aprenderá mais em breve.\n\npinguins\n#&gt; # A tibble: 344 × 8\n#&gt;   especie           ilha      comprimento_bico profundidade_bico\n#&gt;   &lt;fct&gt;             &lt;fct&gt;                &lt;dbl&gt;             &lt;dbl&gt;\n#&gt; 1 Pinguim-de-adélia Torgersen             39.1              18.7\n#&gt; 2 Pinguim-de-adélia Torgersen             39.5              17.4\n#&gt; 3 Pinguim-de-adélia Torgersen             40.3              18  \n#&gt; 4 Pinguim-de-adélia Torgersen             NA                NA  \n#&gt; 5 Pinguim-de-adélia Torgersen             36.7              19.3\n#&gt; 6 Pinguim-de-adélia Torgersen             39.3              20.6\n#&gt; # ℹ 338 more rows\n#&gt; # ℹ 4 more variables: comprimento_nadadeira &lt;int&gt;, massa_corporal &lt;int&gt;, …\n\nEste data frame contém 8 colunas. Para uma visualização alternativa, onde você pode ver todas as variáveis e as primeiras observações de cada variável, use glimpse(). Ou, se você estiver no RStudio, execute View(pinguins) para abrir um visualizador de dados interativo.\n\nglimpse(pinguins)\n#&gt; Rows: 344\n#&gt; Columns: 8\n#&gt; $ especie               &lt;fct&gt; Pinguim-de-adélia, Pinguim-de-adélia, Pinguim…\n#&gt; $ ilha                  &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, T…\n#&gt; $ comprimento_bico      &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2,…\n#&gt; $ profundidade_bico     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6,…\n#&gt; $ comprimento_nadadeira &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 1…\n#&gt; $ massa_corporal        &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675,…\n#&gt; $ sexo                  &lt;fct&gt; macho, fêmea, fêmea, NA, fêmea, macho, fêmea,…\n#&gt; $ ano                   &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 200…\n\nEntre as variáveis em pinguins estão:\n\nespecie: a espécie de um pinguim (Pinguim-de-adélia, Pinguim-de-barbicha e Pinguim-gentoo).\ncomprimento_nadadeira: comprimento da nadadeira de um pinguim, em milímetros.\nmassa_corporal: massa corporal de um pinguim, em gramas.\n\nPara saber mais sobre pinguins, abra sua página de ajuda executando ?pinguins.\n\n1.2.2 Objetivo final\nNosso objetivo final neste capítulo é recriar a seguinte visualização que exibe a relação entre o comprimento da nadadeira e a massa corporal desses pinguins, levando em consideração a espécie do pinguim.\n\n\n\n\n\n\n1.2.3 Criando um gráfico ggplot\nVamos recriar esse gráfico passo a passo.\nNo ggplot2, você inicia um gráfico com a função ggplot(), definindo um objeto de gráfico ao qual você adiciona camadas. O primeiro argumento da função ggplot() é o conjunto de dados a ser usado no gráfico e, portanto, ggplot(data = pinguins) cria um gráfico vazio que está preparado para exibir os dados dos pinguins, mas, como ainda não dissemos como fazer a visualização, por enquanto ele está vazio. Esse não é um gráfico muito interessante, mas você pode pensar nele como uma tela vazia na qual você pintará as camadas restantes do seu gráfico.\n\nggplot(data = pinguins)\n\n\n\n\nEm seguida, precisamos informar ao ggplot() como as informações dos nossos dados serão representadas visualmente. O argumento mapping (mapeamento) da função ggplot() define como as variáveis em seu conjunto de dados são mapeadas para as propriedades visuais (estética) do gráfico. O argumento mapping é sempre definido na função aes(), e os argumentos x e y de aes() especificam quais variáveis devem ser mapeadas nos eixos x e y. Por enquanto, mapearemos apenas o comprimento da nadadeira para o atributo estético x e a massa corporal para o atributo y. O ggplot2 procura as variáveis mapeadas no argumento data, nesse caso, pinguins.\nO gráfico a seguir mostra o resultado da adição desses mapeamentos.\n\nggplot(\n  data = pinguins,\n  mapping = aes(x = comprimento_nadadeira, y = massa_corporal)\n)\n\n\n\n\nNossa tela vazia agora está mais estruturada: está claro onde os comprimentos das nadadeiras serão exibidos (no eixo x) e onde as massas corporais serão exibidas (no eixo y). Mas os pinguins em si ainda não estão no gráfico. Isso ocorre porque ainda não definimos, em nosso código, como representar as observações de nosso data frame em nosso gráfico.\nPara isso, precisamos definir um geom: A geometria que um gráfico usa para representar os dados. Essas geometrias são disponibilizados no ggplot2 com funções que começam com geom_. As pessoas geralmente descrevem os gráficos pelo tipo de geom que o gráfico usa. Por exemplo, os gráficos de barras usam geometrias de barras (geom_bar()), os gráficos de linhas usam geometrias de linhas (geom_line()), os boxplots usam geometrias de boxplot (geom_boxplot()), os gráficos de dispersão usam geometrias de pontos (geom_point()) e assim por diante.\nA função geom_point() adiciona uma camada de pontos ao seu gráfico, o que cria um gráfico de dispersão. O ggplot2 vem com muitas funções de geometria, cada uma adicionando um tipo diferente de camada a um gráfico. Você aprenderá várias geometrias ao longo do livro, principalmente em ?sec-layers.\n\nggplot(\n  data = pinguins,\n  mapping = aes(x = comprimento_nadadeira, y = massa_corporal)\n) +\n  geom_point()\n#&gt; Warning: Removed 2 rows containing missing values (`geom_point()`).\n\n\n\n\nAgora temos algo que se parece com o que poderíamos chamar de “gráfico de dispersão”. Ele ainda não corresponde ao nosso gráfico mostrado no início da seção “objetivo final”, mas, usando esse gráfico, podemos começar a responder à pergunta que motivou nossa exploração: “Como é a relação entre o comprimento da nadadeira e a massa corporal?” A relação parece ser positiva (à medida que o comprimento da nadadeira aumenta, a massa corporal também aumenta), razoavelmente linear (os pontos estão agrupados em torno de uma linha em vez de uma curva) e moderadamente forte (não há muita dispersão em torno dessa linha). Os pinguins com nadadeiras mais longas geralmente são maiores em termos de massa corporal.\nAntes de adicionarmos mais camadas a esse gráfico, vamos parar por um momento e revisar a mensagem de aviso que recebemos:\n\nRemoved 2 rows containing missing values (geom_point()).\n\nEstamos vendo essa mensagem porque há dois pinguins em nosso conjunto de dados com valores faltantes (missing values - NA*) de massa corporal e/ou comprimento da nadadeira e o ggplot2 não tem como representá-los no gráfico sem esses dois valores. Assim como o R, o ggplot2 adota a filosofia de que os valores faltantes nunca devem desaparecer silenciosamente. Esse tipo de aviso é provavelmente um dos tipos mais comuns de avisos que você verá ao trabalhar com dados reais - os valores faltantes são um problema muito comum e você aprenderá mais sobre eles ao longo do livro, especialmente em ?sec-missing-values. Nos demais gráficos deste capítulo, vamos suprimir esse aviso para que ele não seja mostrado em cada gráfico que fizermos.\n\n1.2.4 Adicionando atributos estéticos e camadas\nGráficos de dispersão são úteis para exibir a relação entre duas variáveis numéricas, mas é sempre uma boa ideia ter uma postura cética em relação a qualquer relação aparente entre duas variáveis e perguntar se pode haver outras variáveis que expliquem ou mudem a natureza dessa relação aparente. Por exemplo, a relação entre o comprimento das nadadeira e a massa corporal difere de acordo com a espécie? Vamos incluir as espécies em nosso gráfico e ver se isso revela alguma ideia adicional sobre a relação aparente entre essas variáveis. Faremos isso representando as espécies com pontos de cores diferentes.\nPara conseguir isso, precisaremos modificar o atributo estético ou a geometria? Se você pensou “no mapeamento estético, dentro de aes()”, você já está pegando o jeito de criar visualizações de dados com o ggplot2! Caso contrário, não se preocupe. Ao longo do livro, você criará muito mais visualizações com ggplot e terá muito mais oportunidades de verificar sua intuição.\n\nggplot(\n  data = pinguins,\n  mapping = aes(x = comprimento_nadadeira, y = massa_corporal, color = especie)\n) +\n  geom_point()\n\n\n\n\nQuando uma variável categórica é mapeada a um atributo estético, o ggplot2 atribui automaticamente um valor único da estética (aqui uma cor única) a cada nível único da variável (cada uma das três espécies), um processo conhecido como dimensionamento. O ggplot2 também adicionará uma legenda que explica quais valores correspondem a quais níveis.\nAgora vamos adicionar mais uma camada: uma curva suave que exibe a relação entre a massa corporal e o comprimento das nadadeiras. Antes de prosseguir, consulte o código acima e pense em como podemos adicionar isso ao nosso gráfico existente.\nComo essa é uma nova geometria que representa nossos dados, adicionaremos uma nova geometria como uma camada sobre o nossa geometria de pontos: geom_smooth(). E especificaremos que queremos desenhar a linha de melhor ajuste com base em um modelo linear (linear model em inglês) com method = \"lm\".\n\nggplot(\n  data = pinguins,\n  mapping = aes(x = comprimento_nadadeira, y = massa_corporal, color = especie)\n) +\n  geom_point() +\n  geom_smooth(method = \"lm\")\n\n\n\n\nAdicionamos linhas com sucesso, mas esse gráfico não se parece com o gráfico do Seção 1.2.2, que tem apenas uma linha para todo o conjunto de dados, em vez de linhas separadas para cada espécie de pinguim.\nQuando os mapeamentos estéticos são definidos em ggplot(), no nível global, eles são passados para cada uma das camadas de geometria (geom) subsequentes do gráfico. Entretanto, cada função geom no ggplot2 também pode receber um argumento mapping, que permite mapeamentos estéticos em nível local que são adicionados àqueles herdados do nível global. Como queremos que os pontos sejam coloridos com base na espécie, mas não queremos que as linhas sejam separadas para eles, devemos especificar color = especie somente para geom_point().\n\nggplot(\n  data = pinguins,\n  mapping = aes(x = comprimento_nadadeira, y = massa_corporal)\n) +\n  geom_point(mapping = aes(color = especie)) +\n  geom_smooth(method = \"lm\")\n\n\n\n\nPronto! Temos algo que se parece muito com nosso objetivo final, embora ainda não esteja perfeito. Ainda precisamos usar formas diferentes para cada espécie de pinguim e melhorar os rótulos.\nGeralmente, não é uma boa ideia representar informações usando apenas cores em um gráfico, pois as pessoas percebem as cores de forma diferente devido ao daltonismo ou a outras diferenças de visão de cores. Portanto, além da cor, também podemos mapear especie para a estética shape (forma).\n\nggplot(\n  data = pinguins,\n  mapping = aes(x = comprimento_nadadeira, y = massa_corporal)\n) +\n  geom_point(mapping = aes(color = especie, shape = especie)) +\n  geom_smooth(method = \"lm\")\n\n\n\n\nObserve que a legenda também é atualizada automaticamente para refletir as diferentes formas dos pontos.\nE, finalmente, podemos melhorar os rótulos do nosso gráfico usando a função labs() em uma nova camada. Alguns dos argumentos de labs() podem ser autoexplicativos: title adiciona um título e subtitle adiciona um subtítulo ao gráfico. Outros argumentos correspondem aos mapeamentos estéticos, x é o rótulo do eixo x, y é o rótulo do eixo y e color e shape definem o rótulo da legenda. Além disso, podemos aprimorar a paleta de cores para que seja segura para pessoas com daltonismo com a função scale_color_colorblind() do pacote ggthemes.\n\nggplot(pinguins, aes(x = comprimento_nadadeira, y = massa_corporal)) +\n  geom_point(aes(color = especie, shape = especie)) +\n  geom_smooth(method = \"lm\") +\n  labs(\n    title = \"Massa corporal e comprimento da nadadeira\",\n    subtitle = \"Medidas para Pinguim-de-adélia, Pinguim-de-barbicha e Pinguim-gentoo\",\n    x = \"Comprimento da nadadeira (mm)\",\n    y = \"Massa corporal (g)\",\n    color = \"Espécie\",\n    shape = \"Espécie\"\n  ) +\n  scale_color_colorblind()\n\n\n\n\nFinalmente temos um gráfico que corresponde perfeitamente ao nosso “objetivo final”!\n\n1.2.5 Exercícios\n\nQuantas linhas existem em pinguins? E quantas colunas?\nO que a variável profundidade_bico no data frame pinguins descreve? Leia a documentação da base pinguins para descobrir, utilizando o comando ?pinguins .\nFaça um gráfico de dispersão de profundidade_bico em função de comprimento_bico. Ou seja, faça um gráfico de dispersão com profundidade_bico no eixo y e comprimento_bico no eixo x. Descreva a relação entre essas duas variáveis.\nO que acontece se você fizer um gráfico de dispersão de especie em função de profundidade_bico? Qual seria uma melhor escolha de geometria (geom)?\nPor que o seguinte erro ocorre e como você poderia corrigi-lo?\n\n\nggplot(data = pinguins) + \n  geom_point()\n\n\nO que o argumento na.rm faz em geom_point()? Qual é o valor padrão do argumento? Crie um gráfico de dispersão em que você use esse argumento definido como TRUE (verdadeiro).\nAdicione a seguinte legenda ao gráfico que você criou no exercício anterior: “Os dados são provenientes do pacote dados”. Dica: dê uma olhada na documentação da função labs().\nRecrie a visualização a seguir. Para qual atributo estético profundidade_bico deve ser mapeada? E ela deve ser mapeada no nível global ou no nível da geometria?\n\n\n\n\n\n\n\nExecute esse código em sua mente e preveja como será o resultado. Em seguida, execute o código no R e verifique suas previsões.\n\n\nggplot(\n  data = pinguins,\n  mapping = aes(x = comprimento_nadadeira, y = massa_corporal, color = ilha)\n) +\n  geom_point() +\n  geom_smooth(se = FALSE)\n\n\nEsses dois gráficos serão diferentes? Por que sim ou por que não?\n\n\nggplot(\n  data = pinguins,\n  mapping = aes(x = comprimento_nadadeira, y = massa_corporal)\n) +\n  geom_point() +\n  geom_smooth()\n\nggplot() +\n  geom_point(\n    data = pinguins,\n    mapping = aes(x = comprimento_nadadeira, y = massa_corporal)\n  ) +\n  geom_smooth(\n    data = pinguins,\n    mapping = aes(x = comprimento_nadadeira, y = massa_corporal)\n  )"
  },
  {
    "objectID": "data-visualize.html#sec-ggplot2-calls",
    "href": "data-visualize.html#sec-ggplot2-calls",
    "title": "1  Visualização de dados",
    "section": "\n1.3 Chamadas ggplot2",
    "text": "1.3 Chamadas ggplot2\nÀ medida que passarmos dessas seções introdutórias, faremos a transição para uma expressão mais concisa do código do ggplot2. Até agora, temos sido muito explícitos, o que é útil quando se está aprendendo:\n\nggplot(\n  data = pinguins,\n  mapping = aes(x = comprimento_nadadeira, y = massa_corporal)\n) +\n  geom_point()\n\nNormalmente, o primeiro ou os dois primeiros argumentos de uma função são tão importantes que você logo saberá usar eles de cor. Os dois primeiros argumentos de ggplot() são data e mapping; no restante do livro, não escreveremos esses nomes. Isso economiza digitação e, ao reduzir a quantidade de texto extra, facilita a visualização das diferenças entre os gráficos. Essa é uma preocupação de programação realmente importante, à qual voltaremos em ?sec-functions.\nReescrevendo o gráfico anterior de forma mais concisa, temos:\n\nggplot(pinguins, aes(x = comprimento_nadadeira, y = massa_corporal)) +\n  geom_point()\n\nNo futuro, você também aprenderá sobre o pipe (encadeamento), |&gt;, que permitirá que você crie esse gráfico com a seguinte sintaxe:\n\npinguins |&gt; \n  ggplot(aes(x = comprimento_nadadeira, y = massa_corporal)) + \n  geom_point()"
  },
  {
    "objectID": "data-visualize.html#visualizando-distribuições",
    "href": "data-visualize.html#visualizando-distribuições",
    "title": "1  Visualização de dados",
    "section": "\n1.4 Visualizando distribuições",
    "text": "1.4 Visualizando distribuições\nA forma como você visualiza a distribuição de uma variável depende do tipo de variável: categórica ou numérica.\n\n1.4.1 Uma variável categórica\nUma variável é categórica se puder assumir apenas um valor de um pequeno conjunto de valores. Para examinar a distribuição de uma variável categórica, você pode usar um gráfico de barras. A altura das barras exibe quantas observações ocorreram com cada valor x.\n\nggplot(pinguins, aes(x = especie)) +\n  geom_bar()\n\n\n\n\nEm gráficos de barras de variáveis categóricas com níveis não ordenados, como a especie de pinguim acima, geralmente é preferível reordenar as barras com base em suas frequências. Para isso, é necessário transformar a variável em um fator (como o R lida com dados categóricos) e, em seguida, reordenar os níveis desse fator.\n\nggplot(pinguins, aes(x = fct_infreq(especie))) +\n  geom_bar()\n\n\n\n\nVocê aprenderá mais sobre fatores e funções para lidar com fatores (como fct_infreq() mostrado acima) em ?sec-factors.\n\n1.4.2 Uma variável numérica\nUma variável é numérica (ou quantitativa) se puder assumir uma ampla gama de valores numéricos e se for possível adicionar, subtrair ou calcular médias com esses valores. As variáveis numéricas podem ser contínuas ou discretas.\nUma visualização comumente usada para distribuições de variáveis contínuas é um histograma.\n\nggplot(pinguins, aes(x = massa_corporal)) +\n  geom_histogram(binwidth = 200)\n\n\n\n\nUm histograma divide o eixo x em intervalos igualmente espaçados e, em seguida, usa a altura de uma barra para exibir o número de observações que se enquadram em cada intervalo. No gráfico acima, a barra mais alta mostra que 39 observações têm um valor massa_corporal entre 3500 e 3700 gramas, que são as bordas esquerda e direita da barra.\nVocê pode definir a largura dos intervalos em um histograma com o argumento binwidth (largura do intervalo), que é medido nas unidades da variável x. Você deve sempre explorar uma variedade de larguras de intervalos ao trabalhar com histogramas, pois diferentes larguras de intervalos podem revelar padrões diferentes. Nos gráficos abaixo, uma largura de intervalo de 20 é muito estreita, resultando em muitas barras, o que dificulta a determinação da forma da distribuição. Da mesma forma, uma largura de intervalo de 2000 é muito alta, resultando em todos os dados sendo agrupados em apenas três barras, o que também dificulta a determinação da forma da distribuição. Uma largura de intervalo de 200 proporciona um balanço mais adequado.\n\nggplot(pinguins, aes(x = massa_corporal)) +\n  geom_histogram(binwidth = 20)\nggplot(pinguins, aes(x = massa_corporal)) +\n  geom_histogram(binwidth = 2000)\n\n\n\n\n\n\n\n\n\n\n\nUma visualização alternativa para distribuições de variáveis numéricas é um gráfico de densidade. Um gráfico de densidade é uma versão suavizada de um histograma e uma alternativa prática, especialmente para dados contínuos provenientes de uma distribuição suavizada subjacente. Não entraremos em detalhes sobre como geom_density() estima a densidade (você pode ler mais sobre isso na documentação da função), mas vamos explicar como a curva de densidade é desenhada com uma analogia. Imagine um histograma feito de blocos de madeira. Em seguida, imagine que você jogue um fio de espaguete cozido sobre ele. A forma que o espaguete assumirá sobre os blocos pode ser considerada como a forma da curva de densidade. Ela mostra menos detalhes do que um histograma, mas pode facilitar a obtenção rápida da forma da distribuição, principalmente com relação à moda (valor que ocorre com maior frequência) e à assimetria.\n\nggplot(pinguins, aes(x = massa_corporal)) +\n  geom_density()\n#&gt; Warning: Removed 2 rows containing non-finite values (`stat_density()`).\n\n\n\n\n\n1.4.3 Exercícios\n\nFaça um gráfico de barras de especie de pinguins, no qual você atribui especie ao atributo estético y. Como esse gráfico é diferente?\nComo os dois gráficos a seguir são diferentes? Qual atributo estético, color ou fill, é mais útil para alterar a cor das barras?\n\n\nggplot(pinguins, aes(x = especie)) +\n  geom_bar(color = \"red\")\n\nggplot(pinguins, aes(x = especie)) +\n  geom_bar(fill = \"red\")\n\n\nO que o argumento bins em geom_histogram() faz?\nFaça um histograma da variável quilate no conjunto de dados diamante que está disponível quando você carrega o pacote dados. Faça experiências com diferentes larguras de intervalo (binwidth). Qual largura de intervalo revela os padrões mais interessantes?"
  },
  {
    "objectID": "data-visualize.html#visualizando-relações",
    "href": "data-visualize.html#visualizando-relações",
    "title": "1  Visualização de dados",
    "section": "\n1.5 Visualizando relações",
    "text": "1.5 Visualizando relações\nPara visualizar uma relação, precisamos ter pelo menos duas variáveis mapeadas para os atributos estéticos de um gráfico. Nas seções a seguir, você aprenderá sobre os gráficos comumente usados para visualizar relações entre duas ou mais variáveis e as geometrias usados para criá-los.\n\n1.5.1 Uma variável numérica e uma variável categórica\nPara visualizar a relação entre uma variável numérica e uma variável categórica, podemos usar diagramas de caixa (chamados boxplots) lado a lado. Um boxplot é um tipo de abreviação visual para medidas de posição (percentis) que descrevem uma distribuição. Também é útil para identificar possíveis outliers. Conforme mostrado em Figura 1.1, cada boxplot consiste em:\n\nUma caixa que indica o intervalo da metade intermediária dos dados, uma distância conhecida como intervalo interquartil (IIQ), que se estende do 25º percentil da distribuição até o 75º percentil. No meio da caixa há uma linha que exibe a mediana, ou seja, o 50º percentil, da distribuição. Essas três linhas lhe dão uma noção da dispersão da distribuição e se a distribuição é ou não simétrica em relação à mediana ou inclinada para um lado.\nPontos que apresentam observações com valores maiores que 1,5 vezes o IIQ de qualquer borda da caixa. Esses pontos discrepantes são incomuns e, por isso, são plotados individualmente.\nUma linha que se estende de cada extremidade da caixa e vai até o ponto mais distante (sem considerar os valores discrepantes - outliers) na distribuição.\n\n\n\n\n\nFigura 1.1: Diagrama mostrando como um boxplot é criado.\n\n\n\nVamos dar uma olhada na distribuição da massa corporal por espécie usando geom_boxplot():\n\nggplot(pinguins, aes(x = especie, y = massa_corporal)) +\n  geom_boxplot()\n\n\n\n\nComo alternativa, podemos criar gráficos de densidade com geom_density().\n\nggplot(pinguins, aes(x = massa_corporal, color = especie)) +\n  geom_density(linewidth = 0.75)\n\n\n\n\nTambém personalizamos a espessura das linhas usando o argumento linewidth para que elas se destaquem um pouco mais contra o plano de fundo.\nAlém disso, podemos mapear especie para os atributos estéticos color e fill e usar o atributo alpha para adicionar transparência às curvas de densidade preenchidas. Esse atributo assume valores entre 0 (completamente transparente) e 1 (completamente opaco). No gráfico a seguir, ela está definida como 0.5.\n\nggplot(pinguins, aes(x = massa_corporal, color = especie, fill = especie)) +\n  geom_density(alpha = 0.5)\n\n\n\n\nObserve a terminologia que usamos aqui:\n\nNós mapeamos variáveis para atributos estéticos se quisermos que o atributo visual representado por esse atributo varie de acordo com os valores dessa variável.\nCaso contrário, nós definimos o valor de um atributo estético.\n\n1.5.2 Duas variáveis categóricas\nPodemos usar gráficos de barras empilhadas para visualizar a relação entre duas variáveis categóricas. Por exemplo, os dois gráficos de barras empilhadas a seguir exibem a relação entre ilha e espécie ou, especificamente, a visualização da distribuição de espécie em cada ilha.\nO primeiro gráfico mostra as frequências de cada espécie de pinguim em cada ilha. O gráfico de frequências mostra que há um número igual de Pinguim-de-adélia em cada ilha. Mas não temos uma boa noção do equilíbrio percentual em cada ilha.\n\nggplot(pinguins, aes(x = ilha, fill = especie)) +\n  geom_bar()\n\n\n\n\nO segundo gráfico é um gráfico de frequência relativa, criado pela definição de position = \"fill\" na geometria, que é mais útil para comparar as distribuições de espécies entre as ilhas, pois não é afetado pelo número desigual de pinguins entre as ilhas. Usando esse gráfico, podemos ver que todos os Pinguim-gentoo vivem na ilha Biscoe e constituem aproximadamente 75% dos pinguins dessa ilha, todos os Pinguim-de-barbicha vivem na ilha Dream e constituem aproximadamente 50% dos pinguins dessa ilha, e os Pinguim-de-adélia vivem nas três ilhas e constituem todos os pinguins da ilha Torgersen.\n\nggplot(pinguins, aes(x = ilha, fill = especie)) +\n  geom_bar(position = \"fill\")\n\n\n\n\nAo criar esses gráficos de barras, mapeamos a variável que será separada em barras para o atributo estético x e a variável que mudará as cores dentro das barras para a estética fill.\n\n1.5.3 Duas variáveis numéricas\nAté agora, você aprendeu sobre gráficos de dispersão (criados com geom_point()) e curvas suaves (criadas com geom_smooth()) para visualizar a relação entre duas variáveis numéricas. Um gráfico de dispersão é provavelmente o gráfico mais usado para visualizar a relação entre duas variáveis numéricas.\n\nggplot(pinguins, aes(x = comprimento_nadadeira, y = massa_corporal)) +\n  geom_point()\n\n\n\n\n\n1.5.4 Três ou mais variáveis\nComo vimos em Seção 1.2.4, podemos incorporar mais variáveis em um gráfico mapeando-as para atributos estéticos adicionais. Por exemplo, no gráfico de dispersão a seguir, as cores dos pontos (color) representam espécies e as formas dos pontos (shape) representam ilhas.\n\nggplot(pinguins, aes(x = comprimento_nadadeira, y = massa_corporal)) +\n  geom_point(aes(color = especie, shape = ilha))\n\n\n\n\nNo entanto, mapear muitos atributos estéticos a um gráfico faz com que ele fique desordenado e difícil de entender. Outra maneira, que é particularmente útil para variáveis categóricas, é dividir seu gráfico em facetas (facets), subdivisões ou janelas que exibem um subconjunto dos dados cada uma.\nPara separar seu gráfico em facetas por uma única variável, use facet_wrap(). O primeiro argumento de facet_wrap() é uma fórmula3, que você cria com ~ seguido do nome de uma variável. A variável que você passa para facet_wrap() deve ser categórica.\n\nggplot(pinguins, aes(x = comprimento_nadadeira, y = massa_corporal)) +\n  geom_point(aes(color = especie, shape = especie)) +\n  facet_wrap(~ilha)\n\n\n\n\nVocê vai aprender sobre muitas outras geometrias para visualizar distribuições de variáveis e relações entre elas em ?sec-layers.\n\n1.5.5 Exercícios\n\nO data frame milhas que acompanha o pacote dados contém observações 234 coletadas pela Agência de Proteção Ambiental dos EUA em modelos de 38 carros. Quais variáveis em milhas são categóricas? Quais variáveis são numéricas? (Dica: digite ?milhas para ler a documentação do conjunto de dados.) Como você pode ver essas informações ao executar milhas?\nFaça um gráfico de dispersão de rodovia (Milhas rodoviárias por galão) em função de cilindrada usando o data frame milhas. Em seguida, mapeie uma terceira variável numérica para color (cor), depois size (tamanho), depois igualmente para color e size e, por fim, shape (forma). Como esses atributos estéticos se comportam de forma diferente para variáveis categóricas e numéricas?\nNo gráfico de dispersão de rodovia vs. cilindrada, o que acontece se você mapear uma terceira variável para linewidth (espessura da linha)?\nO que acontece se você mapear a mesma variável para várias atributos estéticos?\nFaça um gráfico de dispersão de profundidade_bico vs. comprimento_bico e pinte os pontos por especie. O que a adição da coloração por especie revela sobre a relação entre essas duas variáveis? E quanto à separação em facetas por especie?\nPor que o seguinte código produz duas legendas separadas? Como você corrigiria isso para combinar as duas legendas?\n\n\nggplot(\n  data = pinguins,\n  mapping = aes(\n    x = comprimento_bico, y = profundidade_bico, \n    color = especie, shape = especie\n  )\n) +\n  geom_point() +\n  labs(color = \"especie\")\n\n\nCrie os dois gráficos de barras empilhadas a seguir. Que pergunta você pode responder com o primeiro? Que pergunta você pode responder com o segundo?\n\n\nggplot(pinguins, aes(x = ilha, fill = especie)) +\n  geom_bar(position = \"fill\")\nggplot(pinguins, aes(x = especie, fill = ilha)) +\n  geom_bar(position = \"fill\")"
  },
  {
    "objectID": "data-visualize.html#sec-ggsave",
    "href": "data-visualize.html#sec-ggsave",
    "title": "1  Visualização de dados",
    "section": "\n1.6 Salvando seus gráficos",
    "text": "1.6 Salvando seus gráficos\nDepois de criar um gráfico, talvez você queira tirá-lo do R salvando-o como uma imagem que possa ser usada em outro lugar. Esse é o objetivo da função ggsave(), que salvará no computador o gráfico criado mais recentemente:\n\nggplot(pinguins, aes(x = comprimento_nadadeira, y = massa_corporal)) +\n  geom_point()\nggsave(filename = \"penguin-plot.png\")\n\nIsso salvará o gráfico no seu diretório de trabalho, um conceito sobre o qual você aprenderá mais em ?sec-workflow-scripts-projects.\nSe você não especificar a largura width e a altura height, elas serão tiradas das dimensões do dispositivo de plotagem atual. Para obter um código reprodutível, você deverá especificá-los. Você pode obter mais informações sobre a função ggsave() na documentação.\nDe modo geral, entretanto, recomendamos que você monte seus relatórios finais usando o Quarto, um sistema de escrita reprodutível que permite intercalar seu código e sua escrita e incluir automaticamente seus gráficos em seus relatórios. Você aprenderá mais sobre o Quarto em ?sec-quarto.\n\n1.6.1 Exercícios\n\nExecute as seguintes linhas de código. Qual dos dois gráficos é salvo como grafico-milhas.png? Por quê?\n\n\nggplot(milhas, aes(x = classe)) +\n  geom_bar()\nggplot(milhas, aes(x = cidade, y = rodovia)) +\n  geom_point()\nggsave(\"grafico-milhas.png\")\n\n\nO que você precisa alterar no código acima para salvar o gráfico como PDF em vez de PNG? Como você poderia descobrir quais tipos de arquivos de imagem funcionariam em ggsave()?"
  },
  {
    "objectID": "data-visualize.html#problemas-comuns",
    "href": "data-visualize.html#problemas-comuns",
    "title": "1  Visualização de dados",
    "section": "\n1.7 Problemas comuns",
    "text": "1.7 Problemas comuns\nAo começar a executar o código em R, é provável que você encontre problemas. Não se preocupe, isso acontece com todo mundo. Todos nós estamos escrevendo código em R há anos, mas todos os dias ainda escrevemos códigos que não funciona na primeira tentativa!\nComece comparando cuidadosamente o código que está executando com o código do livro. O R é extremamente exigente, e um caractere mal colocado pode fazer toda a diferença. Certifique-se de que cada ( seja combinado com um ) e que cada \" seja combinado com outra \". Às vezes, você executará o código e nada acontecerá. Verifique o lado esquerdo do console: se houver um +, isso significa que o R acha que você não digitou uma expressão completa e está esperando que você a termine. Nesse caso, geralmente é fácil começar do zero novamente pressionando Esc para interromper o processamento do comando atual.\nUm problema comum ao criar gráficos ggplot2 é colocar o + no lugar errado: ele deve vir no final da linha, não no início. Em outras palavras, certifique-se de não ter escrito acidentalmente um código como este:\n\nggplot(data = milhas) \n+ geom_point(mapping = aes(x = cilindrada, y = rodovia))\n\nSe você ainda estiver com dificuldades, tente a ajuda (painel Help). Você pode obter ajuda sobre qualquer função do R executando ?nome_da_função no console ou selecionando o nome da função e pressionando F1 no RStudio. Não se preocupe se a ajuda não parecer muito útil - em vez disso, pule para os exemplos e procure um código que corresponda ao que você está tentando fazer.\nSe isso não ajudar, leia atentamente a mensagem de erro. Às vezes, a resposta estará escondida lá! Mas quando você é iniciante no R, mesmo que a resposta esteja na mensagem de erro, talvez você ainda não saiba como entendê-la. Outra ferramenta excelente é o Google: tente pesquisar a mensagem de erro no Google, pois é provável que outra pessoa tenha tido o mesmo problema e tenha obtido ajuda on-line."
  },
  {
    "objectID": "data-visualize.html#resumo",
    "href": "data-visualize.html#resumo",
    "title": "1  Visualização de dados",
    "section": "\n1.8 Resumo",
    "text": "1.8 Resumo\nNeste capítulo, você aprendeu os fundamentos da visualização de dados com o ggplot2. Começamos com a ideia básica que sustenta o ggplot2: uma visualização é um mapeamento de variáveis em seus dados para atributos estéticos como posição (position), cor (color), tamanho (size) e forma (shape). Em seguida, você aprendeu a aumentar a complexidade e melhorar a apresentação de seus gráficos camada por camada. Você também aprendeu sobre gráficos comumente usados para visualizar a distribuição de uma única variável, bem como para visualizar relações entre duas ou mais variáveis ao utilizar mapeamentos de atributos estéticos adicionais e/ou dividindo seu gráfico em pequenos gráficos usando facetas.\nUsaremos as visualizações repetidamente ao longo deste livro, introduzindo novas técnicas à medida que precisarmos delas, além de nos aprofundarmos na criação de visualizações com o ggplot2 em ?sec-layers por meio da ?sec-communication.\nCom as noções básicas de visualização em seu currículo, no próximo capítulo mudaremos um pouco a direção e daremos algumas orientações práticas sobre o fluxo de trabalho. Intercalamos conselhos sobre fluxo de trabalho com ferramentas de ciência de dados ao longo desta parte do livro, pois isso te ajudará a manter a organização à medida que você escreve quantidades cada vez maiores de código em R."
  },
  {
    "objectID": "data-visualize.html#footnotes",
    "href": "data-visualize.html#footnotes",
    "title": "1  Visualização de dados",
    "section": "",
    "text": "Você pode eliminar essa mensagem e forçar com que a resolução de conflitos aconteça sob demanda utilizando o pacote conflicted, que se torna mais importante à medida que carrega mais pacotes. Você pode ler mais sobre o pacote conflicted no endereço https://conflicted.r-lib.org.↩︎\nHorst AM, Hill AP, Gorman KB (2020). palmerpinguins: Palmer Archipelago (Antarctica) penguin data. R package version 0.1.0. https://allisonhorst.github.io/palmerpinguins/. doi: 10.5281/zenodo.3960218.↩︎\nAqui “fórmula” é o nome da coisa criada por ~, não um sinônimo de “equação”.↩︎"
  }
]